#!/usr/bin/python
# This file is a draft for the futur helming/procedure system, nomenclature and variable/class names are likely to change

# TODO
# import stuff

# Sheet control
WIND      = object()
SHEET_IN  = object()
SHEET_OUT = object()

# Rudder control
PID_GOAL_HEADING  = object()
PID_ANGLE_TO_WIND = object() # set an angle to the wind, 0 being going torward the wind, can be either 0/360 or -180/180
RUDDER_FULL_LEFT  = object() # the boat is going to the left
RUDDER_FULL_RIGHT = object() # the boat is going to the right

# Publishers for rudder and sailsheet control
PUB_RUDDER    = rospy.Publisher('rudder_control', Int16, queue_size=10)  # Use UInt 16 here to minimize the memory use
PUB_SAILSHEET = rospy.Publisher('sailsheet_normalized', Float32, queue_size=10)

controller = _PID.PID(rudder['control']['Kp'], rudder['control']['Ki'], rudder['control']['Kd'],rudder['maxAngle'], -rudder['maxAngle'])

sail_table_dict = rospy.get_param('sailsettings/table')
sheet_out_to_jibe = rospy.get_param('sailsettings/sheet_out_to_jibe', False)
sail_table = SailTable(sail_table_dict)
sail_data = SailData(sail_table)



def set_sail(sheet_control):
    if sheet_control is WIND:
        sheet_normalized = sail_data.calculate_sheet_setting()
        
    elif sheet_control is IN:
        sheet_normalized = 0

    elif sheet_control is OUT:
        sheet_normalized = 1

    elif sheet_control is float:
        sheet_normalized = sheet_control

    PUB_SAILSHEET.publish(sailsheet_normalized)
    

def set_rudder(state, angle_to_wind=0):
    if state is PID_GOAL_HEADING:
        rawangle = -controller.update_PID(angle_subtract(data.heading, data.goal_heading))
        angle = _PID.saturation(rawangle,-rudder['maxAngle'], rudder['maxAngle'])

    elif state is PID_ANGLE_TO_WIND:
#         rawangle = -controller.update_PID(angle_subtract(data.heading, data.goal_heading))
#         angle = _PID.saturation(rawangle,-rudder['maxAngle'], rudder['maxAngle'])

    elif state is RUDDER_TO_LEFT:
        angle = rudder['maxAngle']
    elif state is RUDDER_TO_RIGHT:
        angle = -rudder['maxAngle']

    PUB_RUDDER.publish(int(angle))





class Helming():
    def __init__(self):
        # subscribe to sailing state

        self.rate = rospy.Rate(rospy.get_param("config/rate"))
        ProcedureList = [tack, jibe, ..]
        self.currentProcedureId = 0

        self.currentProcedure = None
        self.Runner()


    def Runner(self):
        while not rospy.is_shutdown():

            if self.sailing_state == 'normal':
                if self.currentProcedure:
                    self.currentProcedure.end()
                    self.currentProcedure = None
                set_rudder(PID)
                set_sail(WIND)
            else:
                self.run_procedure()
            
            self.rate.sleep()


    def run_procedure(self):
        if not self.currentProcedure:
            # no procedure have been started
            self.currentProcedureId = 0
            self.currentProcedure = ProcedureList[self.currentProcedureId](self.sailing_state)

        elif self.currentProcedure.check_timeout():
            # if time out we start the next procedure in the list
            self.currentProcedureId = (self.currentProcedureId + 1) % len(self.ProcedureList)
            self.currentProcedure = ProcedureList[self.currentProcedureId](self.sailing_state)

        # we advance to the next timestep 
        self.currentProcedure.loop()



########################################################################






class ProcedureBase():
    def __Init__(self):
        self.start_time = ...
        # TODO: subscribe to stuff 

    def is_failed(self):
        """
        Am I out of time?
        Am I failing?
        """
        return currenttime - self.start_time > self.timeout

    def time(self):
        currenttime = ...
        return currenttime - self.start_time 

    def end(self):


class TackBasic(ProcedureBase):
    """
        Basic Tack procedure
    """
    def __Init__(self, sailing_state, timeout=15):
        super().__Init__(self)
        self.sailing_state = sailing_state

    def loop(self):
        set_sail(WIND)
        if self.sailing_state == "switch_to_port_tack":
            set_rudder(MIN)
        else:
            set_rudder(MAX)



class JibeBasic(ProcedureBase):
    """
        Basic Jibe procedure
    """
    def __Init__(self, sailing_state, timeout=15):
        super().__Init__(self)
        self.sailing_state = sailing_state

    def loop(self):
        set_sail.wind()
        if self.sailing_state == "switch_to_port_tack":
            set_rudder.max()
        else:
            set_rudder.min()

class Tack_IncreaseAngleToWind(ProcedureBase):
    """
        Basic Tack procedure
    """
    def __Init__(self, sailing_state, timeout=15):
        super().__Init__(self)
        self.sailing_state = sailing_state
        self.beating_angle = 80

    def loop(self):
        set_sail.wind()
        if self.time() < 5:
            if self.sailing_state == "switch_to_port_tack":
                set_rudder(TO WIND, angle_to_wind = self.beating_angle)
            else:
                set_rudder(TO WIND, angle_to_wind = 360-self.beating_angle)  
        else:
            if self.sailing_state == "switch_to_port_tack":
                set_rudder.min()
            else:
                set_rudder.max()

